# Secret Share App

A secure, full-stack application.
**Frontend**: React (Vite)
**Backend**: Express + MongoDB + Supabase

---

## 1. Setup

### A. Prerequisites
1.  **MongoDB Atlas**: Get connection string.
2.  **Supabase**: For storing the data on cloud

### B. Backend
1.  `cd backend`
2.  `npm install`
3.  Create `.env`:
    ```
    MONGO_URI=...
    SUPABASE_URL=...
    SUPABASE_KEY=...
    ```
4.  `node server.js` (Runs on port 5000)

### C. Frontend
1.  `cd frontend`
2.  `npm install` (Installs React and Vite)
3.  `npm run dev` (Runs on port 5173)
4.  Open browser link shown in terminal.

---

## API Overview

Base URL: `http://localhost:5000/api`

#### 1. Create Secret
**POST** `/secrets`

Accepts `multipart/form-data`.

**Parameters:**
*   `type`: "text" | "file"
*   `text`: String (required if type is text)
*   `file`: Binary (required if type is file)
*   `password`: String (optional)
*   `maxViews`: Number (default 1)
*   `expirationMinutes`: Number (default 60)

**Response:**
```json
{
  "id": "60d5ec...",
  "deleteToken": "a1b2c3...",
  "expiresAt": "2023-10-10T12:00:00.000Z"
}
```

#### 2. Retrieve Secret
**POST** `/secrets/retrieve`

**Body:**
```json
{
  "id": "60d5ec...",
  "password": "optional_password"
}
```

**Response (Text):**
```json
{
  "type": "text",
  "text": "This is the secret",
  "viewsLeft": 0,
  "isLastView": true
}
```

**Response (File):**
```json
{
  "type": "file",
  "file": {
    "name": "image.png",
    "url": "https://supabase-storage-url..."
  },
  "viewsLeft": 0,
  "isLastView": true
}
```

#### 3. Delete Secret
**POST** `/secrets/delete`

Manual deletion before expiration.

**Body:**
```json
{
  "id": "60d5ec...",
  "deleteToken": "a1b2c3..."
}
```

---


## 2. Architecture
*   **Vite**: Handles React build/dev server.
*   **Express**: Handles API and Cloud logic.
*   **Supabase**: Stores files.
*   **MongoDB**: Stores metadata.



## Design Decisions

### Architecture Separation
The project is split into `frontend` (Vite/React) and `backend` (Express/Node). This allows for independent scaling. For example, the frontend could be deployed to a CDN (Vercel/Netlify) while the backend runs on a container service (Render/Heroku/AWS).

### Database vs. Storage Strategy
*   **MongoDB**: Used for storing metadata (passwords, view counts, expiration dates) because of its flexibility and speed with JSON-like documents.
*   **Supabase Storage**: Used for binary file storage. Storing large blobs in MongoDB (GridFS) can be complex to scale and impacts database performance.
### Cleanup Logic
*   **Lazy Cleanup**: Secrets are checked for expiration/view-limits at the moment of access. If expired, they are deleted immediately, and a 410 error is returned.
*   **Active Cleanup**: A background interval runs every 60 seconds on the server to sweep and remove expired records that haven't been accessed, ensuring the database doesn't grow indefinitely.
*   **Cloud Deletion Latency**: When a user views a "file" secret for the last time, the database record is deleted immediately to prevent reuse. However, the deletion of the file from Supabase is delayed by 10 seconds. This prevents race conditions where the file is deleted before the user's browser begins the download.


## Assumptions and Limitations

1.  **Server Persistence**: The background cleanup job (`setInterval`) relies on the Node.js process staying alive. In a serverless environment, this background job would not run reliably. A dedicated cron service would be required for serverless deployment.
2.  **File Size**: The file upload is currently hardcapped at 5MB in the Multer configuration to prevent memory overflow, as files are briefly held in RAM before uploading to Supabase.
3.  **Security**: While the application generates a signed URL (public) for Supabase, the file remains publicly accessible if someone guesses the exact long UUID generated by Supabase until the delete trigger runs.
4.  **Concurrency**: There is a minor race condition window if two users access a "1 view left" secret at the exact same millisecond. MongoDB's atomic operations handle the view count decrement safely, but edge cases in distributed deployments might allow a double view.
